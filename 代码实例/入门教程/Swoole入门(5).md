#Swoole入门(5)
****

###什么是进程？什么是上下文、上下文切换？
>进程包含三个要素：
>>1.一个可执行的程序。
>
>>2.和该进程相关的数据；包括变量、内存空间、缓冲区等。
>
>>3.程序的执行上下文。
>
>>【总结】：
>>>1.进程就是一个可执行程序的一次执行过程中的一个状态。
>
>>>2.系统中有个进程表，进程表中的每一项记录了每个进程当前的状态，方便系统的管理。

>什么是上下文？
>>上下文可以理解为当时的环境，环境可以包括当时**程序状态**以及**变量的状态**
>
>什么是上下文切换？
>>上下文切换（Context Switch）是一种将CPU资源从一个进程分配给另一个进程的机制之前，会保存**现场环境**，大概就是保存当前进程的状态（寄存器值，内存空间指针，相关文件的操作），然后再把资源分配到其他进程，等下次该进程获得了cpu时间的时候再**恢复现场**，大概就是恢复该进程保存的状态，保证进程的正常运行。
>
>>从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。

###示例代码

    #include <unistd.h>
    #include <sys/types.h>
    
    main(){
        pid_t pid;
        pid = fork();
    
        if(pid < 0){
            printf("error fork");
        }else if(pid ==0){
            printf("I am chlid process, my process id is /d\n", getpid());
        }else{
            printf("I am parent process, my process id is /d\n", getpid())
        }
    
    }

>代码输出
>
    I am chlid process, my process id is 5886
    I am parent process, my process id is 5887

>代码讲解
>>当程序执行到`pid = fork();`时候，操作系统会创建一个子进程，并在进程表中添加相应数据项。
>
>>该进程和父进程的可执行程序是**同一个程序**；上下文数据，代码，变量都是原父进程的**拷贝**；但他们是**相互独立的进程**。正如`fork`的原意：**分叉**，从此这两个进程就分道扬镳了，**分别做不一样的工作，实现不同的业务逻辑**，不过两个进程一直同时在运行中。
>
>>父进程继续执行，系统执行`pid = fork();`后返回pid，发现pid大于0，就输出了`I am parent process, my process id is 5887`。
>
>>随后子进程再某个时候被执行到，系统执行`pid = fork();`后返回pid，发现pid等于0，就输出了`I am chlid process, my process id is 5886`。这里需要注意的是该进程不是父进程了，虽然是同一个程序，但是是同一个程序的另外一次执行，执行者是子进程。


###结语
>接下来继续给大家讲讲同步/异步和阻塞/非阻塞的区别，以及管道相关概念。